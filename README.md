1. install docker
2. install vscode
3. open several terminals

# Введение
Главная моя идея продемонстрировать похожесть языков друг на друга и то, что технология развивается эволюционно и современные технологии, до сих пор несут на себе отпечаток решений принятых десятилетия, если не столетия, назад.

*Шутка про задницу коня и шаттл*

## Языки
Языки делятся на высокоуровневые и низкоуровневые, современные и старые. 

*График языков*

К сожалению, в новых языках сильно ограничена возможность работы с *низкоуровневым/опасным?* кодом который требует квалификации и понимания принципов работы процессора и памяти. 

Высокоуровневые языки скрывают эти механизмы за слоями абстракций и поэтому работа может казаться магией. Я намеренно добавил с++ чтобы продемонстрировать низкоуровневую работу, которая недоступна многим языкам и то как происходит переход к высокоуровневым абстракциям.

# Вывод текста
## Терминал

*Картинка телетайпа* Раньше компьютеры были в виде мейнфреймов – больших залов заставленных стойками с оборудованием, а подключались к ним с телетайпов: печатных машинок совмещенных с принтерами. Сотрудник печатал команду, она передавалась по линиям связи, мейнфрейм выполнял команду и передавал ответ, который печатался на принтере. Затем принтер заменился на экран, появились персональные компьютеры, а концепция терминала, куда печатаешь команду и получаешь ответ так и работает спустя 50 лет.

Терминал
`echo 123 abc`

## REPL
программа и параметры
каждая программа состоит из потока ввода, потока вывода и потока ошибок
при запуске программа получает аргументы
после завершения работы возвращает числовой код ошибки. Если ошибки нет то код 0

Откроем 5 терминалов и вызовем команды

```
docker run -it nix python
docker run -it nix irb
docker run -it nix cling
docker run -it nix ki
docker run -it nix node
```

## Вывод текста

ki: `print("123")`

python: `print("123")`

irb: `print("123")`

cling:
```
    #include <cstdio>
    printf("123")
```
node: `console.log("123")`

`print` – это функция которая печатает в стандартный поток вывода строку.

строка это массив символов

почти во всех языках строка записывается в виде литерала (не исполняемого кода, которые передаются как есть) заключенного в двойные или одинарные кавычки. Интерпретируемые языки такие как python, ruby, js поддерживают оба вида литералов.

питон добавляет перевод строки

язык состоит из синтаксиса - очень маленького набора правил и стандартной библиотеки. 

библиотека – это логически и физически сгруппированный набор кода (классов, методов, функций, процедур) для того чтобы избегать замусоривания и дубликатов. Также используется для ускорения кода: подключается только то что необходимо. Почти всегда логическое отображение задается расположением кода в папках и подпапках.

функция аналогична математической: получает что-то на вход и возвращает результат. Функция может ничего не возвращать, как например принт, в бейсике такое называлось процедурой. В современных языка процедур нет, а вместо них функции которые возвращают специальное пустое значение void или nil.

Модули могут содержать подмодули и обычно разделяются точками. Но могут разделяться через / в с/с++ или :: в руби

Можно видеть что в с функция печати не доступна по-умолчанию и приходится её подключать. При этом в js функции печати нет, но есть модуль console и метод log.

## Документация
По всем функциям есть документация

функция print в модуле kotlin.io
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/print.html
функция print в модуле IO https://www.rubydoc.info/stdlib/core/IO:print
функция print без модуля https://docs.python.org/3/library/functions.html#print
функция printf из модуля cstdio https://en.cppreference.com/w/cpp/io/c/printf

## Выход

Выход из компилятора обычно при помощи ctrl+d. Либо 
в ki можно послать команду repl `:q`
в python `quit()`
в руби `quit`
в clang `.q`
в js `process.exit()`

## Кодировка

Продолжаем работу со строками и рассмотрим перевод строки. Раньше каждый символ кодировался одним байтом и было всего 2^8=256 значений. Очевидно их не хватало и поэтому существовали кодировки где первые 128 символов были одинаковые а вторые 128 были специфичны для каждого языка. Самые распростаненные кодировки это `latin-1` или `win-1251` с кириллицей. Если кодировка была неправильная то мы видели кракозябры вместо текста.

*таблица символов*

В таблице символов, есть непечатаемые или управляющие символы. Один из них это LF, Line Feed, 0A, 10 который "прокручивает бумагу" на одну строку вверх и CR, Carriage return, 0D, 13 который переводит "печатающую головку" влево. https://en.wikipedia.org/wiki/Newline. Эти символы пришли к нам из эпохи Морзе 1870-го года. В разных системах они используются по-разному: в Windows перевод строки в текстовом файле обозначается СR LF, в Linux системах достаточно только LF. Поэтому если мы откроем текстовый файл созданный в Linux в Блокноте на Windows мы увидем как все строки слиплись в одну – это из-за того, что блокнот переносит строку только если встретт оба символа.